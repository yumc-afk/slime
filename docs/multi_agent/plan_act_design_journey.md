# Plan/Act 设计之旅：一个关于理解、直觉与优雅的故事

这是一个关于如何在复杂系统中寻找简单解决方案的故事。

## 序章：一个简单的想法

> "我想的简化方法是基于目前single agent的代码，提交两次；但是中间加个scheduler。"

这个看似简单的想法，蕴含着深刻的洞察：**大模型擅长规划，小模型适合执行**。这种异构协作模式不仅能降低成本，还能提高效率。

但如何在slime这样一个精密的分布式系统中实现这个想法？这就是我们的设计之旅。

## 第一章：错误的开始，正确的方向

### 初次尝试：破坏性思维

我最初的想法是把slime"拆开"：
- 一个job只负责rollout（数据生成）
- 另一个job只负责training（模型训练）
- 通过scheduler协调两者

这似乎很合理，对吧？

### 关键时刻：理解架构的完整性

用户的一句话点醒了我：
> "你这个方案的困难之处在于megatron/sglang的资源分配和调度。"

这让我意识到，slime不是一个可以随意拆解的系统。它更像一个**精密的瑞士手表**：
- Megatron的TP/PP/EP并行需要精确的GPU拓扑
- SGLang推理引擎与训练进程共享复杂的资源管理
- NCCL通信组形成了不可分割的网络

**第一个设计洞察**：优秀的架构有其内在的完整性，我们应该**尊重而非破坏**这种完整性。

## 第二章：寻找正确的抽象层次

### 发现扩展点：Buffer的秘密

经过深入研究，我发现了slime的一个优雅设计：
- Buffer不是简单的数据缓冲，而是**控制中心**
- 它通过`generate_rollout`函数暴露了完美的扩展点
- 通过`--rollout-function-path`参数，我们可以注入自定义逻辑

这就像找到了瑞士手表的**上发条口**——不需要拆开手表，就能影响它的运行。

### 设计决策：保持job的完整性

```
正确方案：
Planner Job (完整slime) ←→ Orchestrator ←→ Actor Job (完整slime)
```

每个job都是完整的slime实例，拥有所有必需的组件。我们只在**数据流层面**进行协调。

**第二个设计洞察**：在正确的抽象层次上工作，比在错误的层次上努力更重要。

## 第三章：让设计符合直觉

### Orchestrator的定位：谁是指挥官？

一个关键问题：orchestrator应该由谁启动？

用户的建议简洁而富有洞察力：
> "orch是不是可以放到plan的train里面启动？这样好像逻辑上更加简洁？"

确实！Planner作为"大脑"，自然应该负责创建协调器。这不仅逻辑清晰，还避免了"谁先启动"的竞态条件。

### Main Loop的优雅实现

用户希望orchestrator能作为main loop：
> "所以还是无法实现有一个orch做main loop？感觉这个比较贴近直觉。"

通过**控制反转**，我们实现了这个愿望：

```python
def plan_act_generate_rollout(args, rollout_id, data_buffer, evaluation=False):
    # 虽然被Buffer调用，但立即将控制权交给orchestrator
    return ray.get(orchestrator.execute_rollout.remote(...))
```

Orchestrator虽然是被动调用的，但获得了主动控制整个流程的能力。这就像**太极推手**——借力打力，四两拨千斤。

**第三个设计洞察**：好的设计应该符合人的直觉和认知模型。

## 第四章：充分利用现有能力

### Ray的馈赠：Detached Actor

Ray提供了一个完美的特性——detached actor：
- 生命周期独立于创建它的job
- 可以通过名称在不同job间访问
- 支持异步操作和并发控制

这简直是为我们的需求量身定制的！

### 同步栅栏：简单而优雅

两个job都会调用orchestrator，如何避免重复执行？

```python
# 同步栅栏模式
if barrier['planner'] and barrier['actor'] and not barrier['executed']:
    barrier['executed'] = True
    # 执行主逻辑
```

这个解决方案体现了**对称性之美**——两个job在架构上完全平等，通过简单的同步机制实现协调。

### Serverless思维：容错是默认的

用户提醒我：
> "超时sglang应该会处理吧？我们这都是标准的serverless服务架构了，容错应该好做？"

这让我意识到，我们不需要过度设计容错机制。SGLang已经提供了：
- 60次重试机制
- Abort和部分恢复能力
- 生产级的稳定性

**第四个设计洞察**：充分利用现有系统的能力，不要重新发明轮子。

## 第五章：从复杂到简单的蜕变

### 第一版：过度工程的陷阱

Sub agent最初创建了一个复杂的实现：
- `planner.py`：包含策略优化、奖励预测等复杂功能
- `actor.py`：有执行历史追踪、性能统计
- `communication.py`：额外的抽象层
- 总计数千行代码

### 最终版：大道至简

经过反思和简化，最终只需要两个文件：
- `plan_act_orchestrator.py`：253行
- `plan_act_rollout.py`：140行

为什么能如此简单？因为我们：
1. **聚焦核心问题**：协调两个job的执行
2. **复用现有能力**：Ray的通信、slime的扩展点
3. **避免过早优化**：先跑通，再优化

**第五个设计洞察**：简单是复杂的最高境界。

## 第六章：架构哲学的体现

### 最小侵入原则

整个Plan/Act功能的实现，只需要：
1. 在train.py添加几行启动逻辑
2. 通过参数注入rollout函数
3. 所有核心逻辑都在独立模块

这就像**外科手术**——精准、最小创伤、快速恢复。

### 约束激发创造力

slime的架构约束看似限制了我们，实际上激发了更优雅的解决方案：
- 不能拆分架构 → 发现了Buffer扩展点
- 不能改变调用流程 → 发明了控制反转方案
- 不能修改核心代码 → 创造了插件化设计

### 失败是最好的老师

每一次"错误"都加深了我们的理解：
- 拆分架构的失败 → 理解了系统的完整性
- 复杂设计的失败 → 认识到简单的价值
- 过度容错的失败 → 学会信任成熟系统

## 终章：设计的智慧

这个设计之旅教会了我们什么？

1. **理解比改造更重要**：深入理解现有系统，找到合适的扩展点
2. **直觉是最好的指南针**：符合直觉的设计往往是正确的
3. **利用而非对抗**：利用系统的特性，而非对抗它们
4. **简单需要勇气**：删除代码比添加代码需要更大的勇气
5. **约束是朋友**：约束迫使我们找到更优雅的解决方案

最终，我们用最少的代码，实现了强大的功能。这不仅是一个技术实现，更是对**系统思维**和**设计美学**的实践。

## 尾声：未来的可能

Plan/Act只是开始。基于这个架构，我们可以探索更多可能：
- 多Agent协作（不只是两个）
- 动态角色切换
- 自适应策略调整

但无论如何扩展，我们都会记住这次旅程的教训：

**在复杂中寻找简单，在约束中发现自由，在理解中获得力量。**

---

*"The best design is not when there is nothing more to add, but when there is nothing left to take away."*  
*— Antoine de Saint-Exupéry*